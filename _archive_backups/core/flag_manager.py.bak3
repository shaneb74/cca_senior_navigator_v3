"""
Flag Manager Service

Central service for managing flag activation, deactivation, and persistence.
Enforces canonical registry compliance and provides provenance tracking.

Key Principles:
- Single source of truth for flag state (flags.active[] in session JSON)
- Registry-validated activation (28 canonical flags only)
- Provenance tracking (who wrote what, when)
- Last-writer-wins conflict resolution
- Backward compatible with legacy GCP flag arrays

API:
    activate(flag_id, source) -> None
    deactivate(flag_id, source) -> None
    get_active() -> List[str]
    get_provenance(flag_id) -> Optional[Dict[str, str]]
"""

import json
import os
from datetime import UTC, datetime
from pathlib import Path

import streamlit as st

from core.events import log_event
from core.flags import VALID_FLAGS

# ==============================================================================
# EXCEPTIONS
# ==============================================================================


class InvalidFlagError(ValueError):
    """Raised when flag_id not in canonical registry"""

    pass


class InvalidConditionError(ValueError):
    """Raised when condition code not in conditions registry"""

    pass


# ==============================================================================
# CONFIGURATION
# ==============================================================================

# Validation mode: "strict" (hard-fail) or "warn" (soft-fail)
VALIDATION_MODE = os.getenv("FLAG_VALIDATION", "strict")

# User data directory
DATA_DIR = Path(__file__).parent.parent / "data" / "users"

# Conditions registry path
CONDITIONS_REGISTRY_PATH = (
    Path(__file__).parent.parent / "config" / "conditions" / "conditions.json"
)

# Lazy-loaded conditions registry
_CONDITIONS_REGISTRY = None


# ==============================================================================
# INTERNAL HELPERS
# ==============================================================================


def _get_user_id() -> str:
    """Get current user ID from session state"""
    if "uid" in st.session_state:
        return st.session_state.uid
    return "anon_default"


def _get_user_file_path() -> Path:
    """Get path to current user's JSON file"""
    user_id = _get_user_id()
    return DATA_DIR / f"{user_id}.json"


def _load_user_session() -> dict:
    """Load user session JSON from disk"""
    file_path = _get_user_file_path()

    if not file_path.exists():
        return {}

    try:
        with open(file_path) as f:
            return json.load(f)
    except (OSError, json.JSONDecodeError) as e:
        print(f"⚠️  Error loading user session: {e}")
        return {}


def _save_user_session(session: dict) -> None:
    """Save user session JSON to disk (atomic write)"""
    file_path = _get_user_file_path()

    # Ensure directory exists
    file_path.parent.mkdir(parents=True, exist_ok=True)

    # Atomic write: write to temp file, then rename
    temp_path = file_path.with_suffix(".tmp")
    try:
        with open(temp_path, "w") as f:
            json.dump(session, f, indent=2)
        temp_path.replace(file_path)
    except OSError as e:
        print(f"⚠️  Error saving user session: {e}")
        if temp_path.exists():
            temp_path.unlink()


def _get_timestamp() -> str:
    """Get current UTC timestamp in ISO 8601 format"""
    return datetime.now(UTC).isoformat().replace("+00:00", "Z")


def _normalize_legacy_flags(session: dict) -> dict[str, any]:
    """
    Normalize legacy flag format to new structure.

    Legacy format:
        mcip_contracts.care_recommendation.flags = [...]

    New format:
        flags.active = [...]
        flags.provenance = {...}

    Returns normalized flags structure (in-memory only, no write)
    """
    # Check if new format already exists
    if "flags" in session and "active" in session.get("flags", {}):
        return session["flags"]

    # Extract legacy flags
    legacy_flags = []

    # Check care_recommendation contract
    try:
        care_rec = session.get("mcip_contracts", {}).get("care_recommendation", {})
        if "flags" in care_rec:
            flags_data = care_rec["flags"]

            # Handle list of dicts (current format)
            if isinstance(flags_data, list):
                for item in flags_data:
                    if isinstance(item, dict) and "id" in item:
                        legacy_flags.append(item["id"])
                    elif isinstance(item, str):
                        legacy_flags.append(item)
            # Handle simple list of strings
            elif isinstance(flags_data, dict):
                # Old format might be dict of flag_id: True
                legacy_flags.extend([k for k, v in flags_data.items() if v])
    except Exception:
        pass

    # Check tiles.gcp_v4.saved_state.flags (old GCP format)
    try:
        gcp_flags = (
            session.get("tiles", {}).get("gcp_v4", {}).get("saved_state", {}).get("flags", {})
        )
        if isinstance(gcp_flags, dict):
            legacy_flags.extend([k for k, v in gcp_flags.items() if v])
    except Exception:
        pass

    # Deduplicate
    legacy_flags = list(set(legacy_flags))

    if not legacy_flags:
        return {"active": [], "provenance": {}}

    # Build normalized structure
    timestamp = _get_timestamp()
    return {
        "active": legacy_flags,
        "provenance": {
            flag_id: {"source": "legacy_gcp", "updated_at": timestamp} for flag_id in legacy_flags
        },
    }


def _load_conditions_registry() -> dict:
    """Load conditions registry from JSON (cached)"""
    global _CONDITIONS_REGISTRY

    if _CONDITIONS_REGISTRY is not None:
        return _CONDITIONS_REGISTRY

    try:
        with open(CONDITIONS_REGISTRY_PATH) as f:
            _CONDITIONS_REGISTRY = json.load(f)
        return _CONDITIONS_REGISTRY
    except (FileNotFoundError, json.JSONDecodeError) as e:
        print(f"⚠️  Error loading conditions registry: {e}")
        return {"conditions": []}


def _get_valid_condition_codes() -> list[str]:
    """Get list of valid condition codes from registry"""
    registry = _load_conditions_registry()
    return [c["code"] for c in registry.get("conditions", [])]


def _validate_flag(flag_id: str, context: str = "unknown") -> None:
    """
    Validate flag_id against canonical registry.

    Args:
        flag_id: Flag identifier to validate
        context: Module/context for error messages

    Raises:
        InvalidFlagError: If flag not in registry (strict mode)
    """
    if flag_id not in VALID_FLAGS:
        # Log validation error
        log_event(
            "flag_validation_error",
            {"flag_id": flag_id, "context": context, "timestamp": _get_timestamp()},
        )

        # Find similar flags (fuzzy match)
        suggestions = [
            valid_flag
            for valid_flag in VALID_FLAGS
            if flag_id.lower() in valid_flag.lower() or valid_flag.lower() in flag_id.lower()
        ][:3]

        error_msg = f"Flag '{flag_id}' not found in canonical registry.\n"
        error_msg += f"  Source: {context}\n"
        if suggestions:
            error_msg += "  Did you mean one of these?\n"
            for suggestion in suggestions:
                error_msg += f"    - {suggestion}\n"
        error_msg += (
            f"  See core/flags.py:FLAG_REGISTRY for all {len(VALID_FLAGS)} canonical flags."
        )

        if VALIDATION_MODE == "strict":
            raise InvalidFlagError(error_msg)
        else:
            print(f"⚠️  WARNING: {error_msg}")


def _validate_condition_code(code: str, context: str = "unknown") -> None:
    """
    Validate condition code against conditions registry.

    Args:
        code: Condition code to validate
        context: Module/context for error messages

    Raises:
        InvalidConditionError: If code not in registry (strict mode)
    """
    valid_codes = _get_valid_condition_codes()

    if code not in valid_codes:
        # Log validation error
        log_event(
            "condition_validation_error",
            {"code": code, "context": context, "timestamp": _get_timestamp()},
        )

        error_msg = f"Condition code '{code}' not found in conditions registry.\n"
        error_msg += f"  Source: {context}\n"
        error_msg += "  See config/conditions/conditions.json for all valid codes."

        if VALIDATION_MODE == "strict":
            raise InvalidConditionError(error_msg)
        else:
            print(f"⚠️  WARNING: {error_msg}")


# ==============================================================================
# PUBLIC API
# ==============================================================================


def activate(flag_id: str, source: str, context: str = None) -> None:
    """
    Activate a flag in the user's session.

    Args:
        flag_id: Canonical flag ID (must exist in FLAG_REGISTRY)
        source: Module identifier (e.g., "gcp", "cp", "pfma")
        context: Optional context for validation errors (e.g., "gcp.mobility_question")

    Raises:
        InvalidFlagError: If flag_id not in registry (strict mode)

    Example:
        activate("mobility_limited", "gcp")
        activate("chronic_present", "pfma", context="pfma.medical_review")
    """
    # Validate flag
    validation_context = context or source
    _validate_flag(flag_id, validation_context)

    # Load session
    session = _load_user_session()

    # Normalize legacy flags if needed
    if "flags" not in session:
        session["flags"] = _normalize_legacy_flags(session)

    # Ensure structure exists
    if "active" not in session["flags"]:
        session["flags"]["active"] = []
    if "provenance" not in session["flags"]:
        session["flags"]["provenance"] = {}

    # Idempotent add to active list
    if flag_id not in session["flags"]["active"]:
        session["flags"]["active"].append(flag_id)

    # Update provenance (always update timestamp, even if re-activating)
    timestamp = _get_timestamp()
    session["flags"]["provenance"][flag_id] = {"source": source, "updated_at": timestamp}

    # Save session
    _save_user_session(session)

    # Log event
    log_event("flag_activated", {"flag_id": flag_id, "source": source, "timestamp": timestamp})


def deactivate(flag_id: str, source: str, context: str = None) -> None:
    """
    Deactivate a flag in the user's session.

    Args:
        flag_id: Flag ID to deactivate
        source: Module identifier (e.g., "gcp", "cp", "pfma")
        context: Optional context for logging

    Note:
        - Validates flag exists in registry (logs warning if not)
        - Removes from flags.active[]
        - Removes from flags.provenance{} (clean state, no archive)
        - No-op if flag not currently active

    Example:
        deactivate("mobility_limited", "gcp")
    """
    # Validate flag (but don't hard-fail on deactivation)
    validation_context = context or source
    try:
        _validate_flag(flag_id, validation_context)
    except InvalidFlagError:
        # Log but continue (allow deactivating invalid flags for cleanup)
        pass

    # Load session
    session = _load_user_session()

    # Normalize legacy flags if needed
    if "flags" not in session:
        session["flags"] = _normalize_legacy_flags(session)

    # Check if flag is active
    active_flags = session.get("flags", {}).get("active", [])
    if flag_id not in active_flags:
        # Already deactivated, no-op
        return

    # Remove from active list
    session["flags"]["active"].remove(flag_id)

    # Remove from provenance (clean state)
    if flag_id in session.get("flags", {}).get("provenance", {}):
        del session["flags"]["provenance"][flag_id]

    # Save session
    _save_user_session(session)

    # Log event
    timestamp = _get_timestamp()
    log_event("flag_deactivated", {"flag_id": flag_id, "source": source, "timestamp": timestamp})


def get_active() -> list[str]:
    """
    Get list of currently active flags.

    Returns:
        List of flag IDs (empty list if no flags)

    Example:
        active = get_active()
        # ["mobility_limited", "chronic_present"]
    """
    session = _load_user_session()

    # Normalize legacy flags if needed
    if "flags" not in session:
        flags_data = _normalize_legacy_flags(session)
        return flags_data.get("active", [])

    return session.get("flags", {}).get("active", [])


def get_provenance(flag_id: str) -> Optional[dict[str, str]]:
    """
    Get provenance metadata for a specific flag.

    Args:
        flag_id: Flag ID to query

    Returns:
        Dict with {source, updated_at} or None if not active

    Example:
        prov = get_provenance("mobility_limited")
        # {"source": "gcp", "updated_at": "2025-10-17T14:32:18Z"}
    """
    session = _load_user_session()

    # Normalize legacy flags if needed
    if "flags" not in session:
        flags_data = _normalize_legacy_flags(session)
        return flags_data.get("provenance", {}).get(flag_id)

    return session.get("flags", {}).get("provenance", {}).get(flag_id)


def get_all_provenance() -> dict[str, dict[str, str]]:
    """
    Get provenance metadata for all active flags.

    Returns:
        Dict mapping flag_id to {source, updated_at}

    Example:
        all_prov = get_all_provenance()
        # {
        #   "mobility_limited": {"source": "gcp", "updated_at": "..."},
        #   "chronic_present": {"source": "pfma", "updated_at": "..."}
        # }
    """
    session = _load_user_session()

    # Normalize legacy flags if needed
    if "flags" not in session:
        flags_data = _normalize_legacy_flags(session)
        return flags_data.get("provenance", {})

    return session.get("flags", {}).get("provenance", {})


def is_valid(flag_id: str) -> bool:
    """
    Check if flag_id is valid (exists in registry).

    Args:
        flag_id: Flag ID to check

    Returns:
        True if valid, False otherwise
    """
    return flag_id in VALID_FLAGS


def validate_flags(flag_ids: list[str], context: str = "unknown") -> list[str]:
    """
    Validate multiple flags against registry.

    Args:
        flag_ids: List of flag IDs to validate
        context: Context for error messages

    Returns:
        List of invalid flag IDs (empty if all valid)
    """
    invalid = []
    for flag_id in flag_ids:
        if flag_id not in VALID_FLAGS:
            invalid.append(flag_id)
            log_event(
                "flag_validation_error",
                {"flag_id": flag_id, "context": context, "timestamp": _get_timestamp()},
            )

    if invalid and VALIDATION_MODE == "strict":
        error_msg = f"Invalid flags from {context}: {invalid}\n"
        error_msg += f"See core/flags.py:FLAG_REGISTRY for all {len(VALID_FLAGS)} canonical flags."
        raise InvalidFlagError(error_msg)

    return invalid


# ==============================================================================
# CHRONIC CONDITION MANAGEMENT
# ==============================================================================


def update_chronic_conditions(condition_codes: list[str], source: str, context: str = None) -> None:
    """
    Update chronic conditions list and auto-activate flags based on count.

    Activation Rules:
        - count >= 1: activate chronic_present
        - count >= 2: activate chronic_conditions
        - count == 0: deactivate both flags
        - count == 1: keep chronic_present, deactivate chronic_conditions

    Args:
        condition_codes: List of condition codes (from conditions registry)
        source: Module identifier (e.g., "gcp", "pfma")
        context: Optional context for validation errors

    Raises:
        InvalidConditionError: If any code not in registry (strict mode)

    Example:
        update_chronic_conditions(["diabetes", "copd"], "gcp")
        # Writes medical.conditions.chronic[]
        # Activates chronic_present + chronic_conditions
    """
    # Validate all condition codes
    validation_context = context or source
    for code in condition_codes:
        _validate_condition_code(code, validation_context)

    # Load session
    session = _load_user_session()

    # Ensure medical.conditions structure exists
    if "medical" not in session:
        session["medical"] = {}
    if "conditions" not in session["medical"]:
        session["medical"]["conditions"] = {}

    # Build condition records
    timestamp = _get_timestamp()
    condition_records = []
    seen_codes = set()

    for code in condition_codes:
        # Deduplicate
        if code in seen_codes:
            continue
        seen_codes.add(code)

        condition_records.append({"code": code, "source": source, "updated_at": timestamp})

    # Write to session
    session["medical"]["conditions"]["chronic"] = condition_records
    _save_user_session(session)

    # Apply flag activation rules
    count = len(condition_records)

    if count == 0:
        # Deactivate both flags
        deactivate("chronic_present", source, context)
        deactivate("chronic_conditions", source, context)
    elif count == 1:
        # Activate chronic_present, deactivate chronic_conditions
        activate("chronic_present", source, context)
        deactivate("chronic_conditions", source, context)
    else:  # count >= 2
        # Activate both flags
        activate("chronic_present", source, context)
        activate("chronic_conditions", source, context)

    # Log event
    log_event(
        "chronic_conditions_updated",
        {
            "condition_codes": condition_codes,
            "count": count,
            "source": source,
            "timestamp": timestamp,
        },
    )


def get_chronic_conditions() -> list[dict[str, str]]:
    """
    Get list of chronic condition records.

    Returns:
        List of condition records with {code, source, updated_at}

    Example:
        conditions = get_chronic_conditions()
        # [
        #   {"code": "diabetes", "source": "gcp", "updated_at": "..."},
        #   {"code": "copd", "source": "gcp", "updated_at": "..."}
        # ]
    """
    session = _load_user_session()
    return session.get("medical", {}).get("conditions", {}).get("chronic", [])


def validate_condition_codes(codes: list[str], context: str = "unknown") -> list[str]:
    """
    Validate multiple condition codes against registry.

    Args:
        codes: List of condition codes to validate
        context: Context for error messages

    Returns:
        List of invalid codes (empty if all valid)
    """
    valid_codes = _get_valid_condition_codes()
    invalid = []

    for code in codes:
        if code not in valid_codes:
            invalid.append(code)
            log_event(
                "condition_validation_error",
                {"code": code, "context": context, "timestamp": _get_timestamp()},
            )

    if invalid and VALIDATION_MODE == "strict":
        error_msg = f"Invalid condition codes from {context}: {invalid}\n"
        error_msg += "See config/conditions/conditions.json for all valid codes."
        raise InvalidConditionError(error_msg)

    return invalid


def get_conditions_registry() -> dict:
    """
    Get full conditions registry.

    Returns:
        Dict with version, updated_at, and conditions array
    """
    return _load_conditions_registry()


# ==============================================================================
# DEBUG UTILITIES
# ==============================================================================


def dump_flag_state() -> None:
    """Print current flags + provenance for debugging"""
    active = get_active()
    provenance = get_all_provenance()

    print(f"\n{'=' * 60}")
    print(f"FLAG STATE FOR USER: {_get_user_id()}")
    print(f"{'=' * 60}")
    print(f"\nActive flags ({len(active)}):")

    if not active:
        print("  (none)")
    else:
        for flag_id in active:
            prov = provenance.get(flag_id, {})
            print(f"  - {flag_id}")
            print(f"      source: {prov.get('source', 'unknown')}")
            print(f"      updated: {prov.get('updated_at', 'unknown')}")

    print(f"\n{'=' * 60}\n")


__all__ = [
    # Exceptions
    "InvalidFlagError",
    "InvalidConditionError",
    # Flag management
    "activate",
    "deactivate",
    "get_active",
    "get_provenance",
    "get_all_provenance",
    "is_valid",
    "validate_flags",
    # Condition management
    "update_chronic_conditions",
    "get_chronic_conditions",
    "validate_condition_codes",
    "get_conditions_registry",
    # Debug
    "dump_flag_state",
    # Config
    "VALIDATION_MODE",
]
